package main

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"text/template"

	"query-service/core"

	"github.com/graphql-go/graphql/language/ast"
)

type FieldData struct {
	Name string
	Type string
}
type TypeData struct {
	TypeName   string
	Fields     []FieldData
	ColumnList string // not used in dynamic queries anymore
}
type FieldType struct {
	Name   string
	IsList bool
}

func main() {
	schema, err := core.LoadSchema("schema.graphql")
	if err != nil {
		log.Fatal(err)
	}
	var types []TypeData
	for tn, def := range schema.Types {
		if tn == "Query" || tn == "Mutation" {
			continue
		}
		td := TypeData{TypeName: tn}
		for _, f := range def.Fields {
			ft := resolveFieldType(f.Type)
			td.Fields = append(td.Fields, FieldData{
				Name: f.Name.Value,
				Type: mapFieldType(ft),
			})
		}
		types = append(types, td)
	}
	tpl, err := template.New("gen").Parse(tplSrc)
	if err != nil {
		log.Fatal(err)
	}
	var buf bytes.Buffer
	if err = tpl.Execute(&buf, types); err != nil {
		log.Fatal(err)
	}
	os.MkdirAll("generated", 0755)
	if err = ioutil.WriteFile("generated/generated.go", buf.Bytes(), 0644); err != nil {
		log.Fatal(err)
	}
	fmt.Println("Generated code in generated/generated.go")
}

func resolveFieldType(t ast.Type) FieldType {
	switch tt := t.(type) {
	case *ast.List:
		ft := resolveFieldType(tt.Type)
		ft.IsList = true
		return ft
	case *ast.NonNull:
		return resolveFieldType(tt.Type)
	case *ast.Named:
		return FieldType{Name: tt.Name.Value, IsList: false}
	}
	return FieldType{}
}

func mapFieldType(ft FieldType) string {
	var base string
	switch ft.Name {
	case "ID":
		base = "graphql.ID"
	case "String":
		base = "graphql.String"
	case "Int":
		base = "graphql.Int"
	case "Float":
		base = "graphql.Float"
	case "Boolean":
		base = "graphql.Boolean"
	default:
		base = ft.Name + "Type"
	}
	if ft.IsList {
		return "graphql.NewList(" + base + ")"
	}
	return base
}

var tplSrc = `// Code generated by cmd/generate/main.go; DO NOT EDIT.
package generated

import (
	"github.com/graphql-go/graphql"
	"query-service/core"
	"log"
)

var QueryFields graphql.Fields

{{range .}}
// Declarations for the custom type and its WhereInput type
var {{.TypeName}}Type *graphql.Object
var {{.TypeName}}WhereInputType *graphql.InputObject
{{end}}

func init() {
	{{range .}}
	{{.TypeName}}Type = graphql.NewObject(graphql.ObjectConfig{
		Name: "{{.TypeName}}",
		Fields: graphql.FieldsThunk(func() graphql.Fields {
			return graphql.Fields{
				{{range .Fields}}"{{.Name}}": &graphql.Field{Type: {{.Type}}},{{end}}
			}
		}),
	})
	{{.TypeName}}WhereInputType = graphql.NewInputObject(graphql.InputObjectConfig{
		Name: "{{.TypeName}}WhereInput",
		Fields: graphql.InputObjectConfigFieldMap{
			{{range .Fields}}"{{.Name}}": &graphql.InputObjectFieldConfig{Type: graphql.String},{{end}}
		},
	})
	{{end}}

	// Build the QueryFields map with two queries per entity.
	// For each entity, one query for find-one (by ID) and one for find-many.
	QueryFields = graphql.Fields{
		{{range .}}
		"{{.TypeName}}": &graphql.Field{
			Type: {{.TypeName}}Type,
			Args: graphql.FieldConfigArgument{
				"id": &graphql.ArgumentConfig{Type: graphql.NewNonNull(graphql.ID)},
			},
			Resolve: func(p graphql.ResolveParams) (interface{}, error) {
				return core.ResolveSingle("{{.TypeName}}", p)
			},
		},
		"{{.TypeName}}s": &graphql.Field{
			Type: graphql.NewList({{.TypeName}}Type),
			Args: graphql.FieldConfigArgument{
				"page":  &graphql.ArgumentConfig{Type: graphql.Int},
				"limit": &graphql.ArgumentConfig{Type: graphql.Int},
				"order": &graphql.ArgumentConfig{Type: graphql.String},
				"where": &graphql.ArgumentConfig{Type: {{.TypeName}}WhereInputType},
			},
			Resolve: func(p graphql.ResolveParams) (interface{}, error) {
				return core.ResolveMultiple("{{.TypeName}}", p)
			},
		},
		{{end}}
	}
}
`
